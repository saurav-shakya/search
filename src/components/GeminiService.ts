import { GoogleGenerativeAI } from "@google/generative-ai";
import { SearchNode } from '../types';
import { generateMockResults } from './MockSearchService';

const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
console.log('API Key length:', API_KEY ? API_KEY.length : 'No API key found');

const genAI = new GoogleGenerativeAI(API_KEY);

export const generateSearchResults = async (query: string): Promise<SearchNode> => {
  if (!API_KEY) {
    console.warn('No API key found. Falling back to mock data.');
    return generateMockResults(query);
  }

  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  console.log('Sending request to Gemini API...');
  
  const prompt = `Generate a hierarchical search result for: "${query}". Provide the result in JSON format with the following structure:
    {
      "id": "1",
      "name": "${query}",
      "category": "main",
      "children": [
        {
          "id": "1.1",
          "name": "Subtopic 1",
          "category": "category1",
          "children": []
        },
        {
          "id": "1.2",
          "name": "Subtopic 2",
          "category": "category2",
          "children": []
        }
      ]
    }
    Use appropriate categories like 'technology', 'science', 'history', etc. Provide 3-5 relevant subtopics as children. Do not include any additional text or code formatting in your response, just the raw JSON.`;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();
    console.log('Received response from Gemini API:', text);
    
    try {
      const cleanedText = text.replace(/```json\s*|\s*```/gi, '').trim();
      const parsedResult = JSON.parse(cleanedText);
      if (!isValidSearchNode(parsedResult)) {
        throw new Error('Invalid response structure');
      }
      return parsedResult;
    } catch (parseError: any) {
      console.error('Error parsing Gemini API response:', parseError);
      throw new Error(`Failed to parse Gemini API response: ${parseError.message}\nReceived: ${text}`);
    }
  } catch (error: any) {
    console.error('Error in Gemini API call:', error);
    if (error.response && error.response.status === 426) {
      console.error('Received 426 Upgrade Required error. This might be due to an outdated client or API version.');
    }
    console.log('Falling back to mock data...');
    return generateMockResults(query);
  }
};

export const generateConciseAnswer = async (query: string): Promise<string> => {
  if (!API_KEY) {
    console.warn('No API key found. Returning mock concise answer.');
    return `This is a mock concise answer for "${query}". In a real scenario, this would be generated by the AI.`;
  }

  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  console.log('Sending concise answer request to Gemini API...');
  
  const prompt = `Provide a concise answer (2-3 sentences) to the following question: "${query}"`;

  try {
    const result = await model.generateContent(prompt);
    const response = result.response;
    const text = response.text();
    console.log('Received concise answer from Gemini API:', text);
    return text.trim();
  } catch (error: any) {
    console.error('Error generating concise answer:', error);
    return `Failed to generate a concise answer for "${query}". Please try again later.`;
  }
};

function isValidSearchNode(node: any): node is SearchNode {
  return (
    typeof node === 'object' &&
    typeof node.id === 'string' &&
    typeof node.name === 'string' &&
    typeof node.category === 'string' &&
    (node.children === undefined || Array.isArray(node.children))
  );
}